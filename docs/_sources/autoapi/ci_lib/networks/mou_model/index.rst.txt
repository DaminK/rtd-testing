:py:mod:`ci_lib.networks.mou_model`
===================================

.. py:module:: ci_lib.networks.mou_model

.. autoapi-nested-parse::

   Copyright 2019 Andrea Insabato, Gorka Zamora-LÃ³pez, Matthieu Gilson

   Released under the Apache License, Version 2.0 (the "License");
   you may not use this software except in compliance with the License.
   You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0

   Main class to deal with construction, simulation and estimation for the 
   multivariate Ornstein-Uhlenbeck (MOU) process.

   ..
       !! processed by numpydoc !!


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   ci_lib.networks.mou_model.MOU




.. py:class:: MOU(C=None, tau_x=1.0, mu=0.0, Sigma=None, random_state=None, logger=None)

   Bases: :py:obj:`sklearn.base.BaseEstimator`

   
   Description of the class and a summary of its parameters, attributes and
   methods.


   :Parameters:

       **n_nodes** : integer
           Number of nodes in the network.

       **J** : ndarray of rank-2
           Jacobian matrix between the nodes. The diagonal corresponds to a vector
           of time constants. For off-diagonal elements, the first dimension 
           corresponds to target nodes and the second dimension to source nodes 
           (J_ij is from i to j).

       **mu** : ndarray of rank-1
           Mean vector of the inputs to the nodes.

       **Sigma** : ndarray of rank-2
           Covariance matrix of the inputs to the nodes (multivariate Wiener process).













   .. rubric:: Methods



   ===============  ==========
         **get_C**  (Returns the connectivity matrix (off-diagonal elements of the) Jacobian).  
     **get_tau_x**  (Returns the time constant (related to the diagonal of the) Jacobian)  
           **fit**  (Fit the model to a time series (time x nodes). The previous parameters) (connectivity, etc.) are erased.  
        **fit_LO**  (Fit method relying on Lyapunov optimization (gradient descent).)   
   **fit_moments**  (Fit method with maximum likelihood.)   
         **score**  (Returns the goodness of fit after the optimization.)   
      **simulate**  (Simulate the activity of the MOU process determined by J, mu and) Sigma.  
   ===============  ==========

   ..
       !! processed by numpydoc !!
   .. py:method:: get_J()

      
      Access to the Jacobian of the MOU process.



      :Returns:

          **J** : ndarray of rank 2
              The Jacobian matrix. The first dimension corresponds to target nodes 
              and the second dimension to source nodes (J_ij is from i to j).













      ..
          !! processed by numpydoc !!

   .. py:method:: get_Sigma()

      
      Access to the covariance matrix of the inputs of the MOU process.



      :Returns:

          **Sigma** : ndarray of rank 2
              The input covariance matrix.













      ..
          !! processed by numpydoc !!

   .. py:method:: get_C()

      
      Access to the connectivity of the MOU process.



      :Returns:

          **C** : ndarray of rank 2
              The connectivity matrix corresponding to the off-diagonal elements 
              of the Jacobian. The first dimension corresponds to source nodes 
              and the second dimension to target nodes (C_ij is from i to j).













      ..
          !! processed by numpydoc !!

   .. py:method:: get_tau_x()

      
      Access to the time constants of the MOU process.



      :Returns:

          **tau_x** : ndarray of rank 1
              Time constants corresponding to the inverse opposite of the diagonal
              elements of the Jacobian.













      ..
          !! processed by numpydoc !!

   .. py:method:: fit(X, y=None, method='lyapunov', **kwargs)

      
      Generic fit method to call the adequate specific method.


      :Parameters:

          **X** : ndarray
              The timeseries data of the system to estimate, of shape:
              T (time points) x n_nodes (numer of variables, e.g. number of ROIs).

          **y** : (for compatibility, not used here).
              ..

          **method** : string (optional)
              Set the optimization method; should be 'lyapunov' or 'moments'.

      :Returns:

          **J** : ndarray of rank 2
              The estimated Jacobian. Shape [n_nodes, n_nodes]

          **Sigma** : ndarray of rank 2
              Estimated input noise covariance. Shape [n_nodes, n_nodes]

          **d_fit** : dictionary
              A dictionary with diagnostics of the fit. Keys are: ['iterations',
              'distance', 'correlation'].













      ..
          !! processed by numpydoc !!

   .. py:method:: fit_LO(Q_obj, i_tau_opt=1, mask_C=None, mask_Sigma=None, epsilon_C=0.0001, epsilon_Sigma=0.01, regul_C=0.0, regul_Sigma=0.0, min_val_C=0.0, max_val_C=1.0, min_val_Sigma_diag=0.0, max_iter=10000, min_iter=10, **kwargs)

      
      Estimation of MOU parameters (connectivity C, noise covariance Sigma,
      and time constant tau_x) with Lyapunov optimization as in: Gilson et al.
      Plos Computational Biology (2016).


      :Parameters:

          **Q_obj** : ndarray
              The covariance matrix

          **i_tau_opt** : integer (optional)
              Mask of known non-zero values for connectivity matrix, for example
              estimated by DTI.

          **mask_C** : boolean ndarray of rank-2 (optional)
              Mask of known non-zero values for connectivity matrix, for example
              estimated by DTI. By default, all connections are allowed (except
              self-connections)

          **mask_Sigma** : boolean ndarray of rank-2 (optional)
              Mask of known non-zero values for the input covariance matrix
              (by default diagonal).

          **epsilon_C** : float (optional)
              Learning rate for connectivity (this should be about n_nodes times
              smaller than epsilon_Sigma).

          **epsilon_Sigma** : float (optional)
              Learning rate for Sigma (this should be about n_nodes times larger
              than epsilon_EC).

          **regul_C** : float (optional)
              Regularization parameter for connectivity. Try first a value of 0.5.

          **regul_Sigma** : float (optional)
              Regularization parameter for Sigma. Try first a value of 0.001.

          **min_val_C** : float (optional)
              Minimum value to bound connectivity estimate. This should be zero
              or slightly negative (too negative limit can bring to an inhibition
              dominated system). If the empirical covariance has many negative
              entries then a slightly negative limit can improve the estimation
              accuracy.

          **max_val_C** : float (optional)
              Maximum value to bound connectivity estimate. This is useful to
              avoid large weight that make the system unstable. If the estimated
              connectivity saturates toward this value (it usually doesn't happen)
              it can be increased.

          **max_iter** : integer (optional)
              Number of maximum optimization steps. If final number of iterations
              reaches this maximum it means the algorithm has not converged.

          **min_iter** : integer (optional)
              Number of minimum optimization steps before testing if end of 
              optimization (increase of model error).

      :Returns:

          **J** : ndarray of rank 2
              The estimated Jacobian. Shape [n_nodes, n_nodes]

          **Sigma** : ndarray of rank 2
              Estimated noise covariance. Shape [n_nodes, n_nodes]

          **d_fit** : dictionary
              A dictionary with diagnostics of the fit. Keys are: ['iterations',
              'distance', 'correlation'].













      ..
          !! processed by numpydoc !!

   .. py:method:: fit_moments(Q0_obj, Q1_obj, mask_C=None)

      
      Estimation of MOU parameters (connectivity C, noise covariance Sigma,
      and time constant tau_x) with moments method.


      :Parameters:

          **Q0_obj** : ndarray of rank 2
              The zero-lag covariance matrix of the time series to fit.

          **Q1_obj** : ndarray of rank 2
              The 1-lag covariance matrix of the time series to fit.

          **mask_C** : boolean ndarray of rank-2 (optional)
              Mask of known non-zero values for connectivity matrix, for example
              estimated by DTI.

      :Returns:

          **J** : ndarray of rank 2
              The estimated Jacobian. Shape [n_nodes, n_nodes]

          **Sigma** : ndarray of rank 2
              Estimated noise covariance. Shape [n_nodes, n_nodes]

          **d_fit** : dictionary
              A dictionary with diagnostics of the fit. Keys are: ['iterations',
              'distance', 'correlation'].













      ..
          !! processed by numpydoc !!

   .. py:method:: score()

      
      Returns the correlation between goodness of fit of the MOU to the 
      data, measured by the Pearson correlation between the obseved 
      covariances and the model covariances. 
















      ..
          !! processed by numpydoc !!

   .. py:method:: model_covariance(tau=0.0)

      
      Calculates theoretical (lagged) covariances of the model given the
      parameters (forward step). Notice that this is not the empirical
      covariance matrix as estimated from simulated time series.


      :Parameters:

          **tau** : scalar
              The time lag to calculate the covariance. It can be a positive or
              negative.

      :Returns:

          **FC** : ndarray of rank-2
              The (lagged) covariance matrix.













      ..
          !! processed by numpydoc !!

   .. py:method:: simulate(T=100, dt=0.05, sampling_step=1.0, random_state=None)

      
      Simulate the MOU process with simple Euler integration defined by the
      time step.


      :Parameters:

          **T** : integer (optional)
              Duration of simulation.

          **dt** : scalar (optional)
              Integration time step.

          **sampling_step** : scalar (optional)
              Period for subsampling the generated time series.

          **random_state** : long or int (optional)
              Description here ...

      :Returns:

          **ts** : ndarray of rank-2
              Time series of simulated network activity of shape [T, n_nodes]








      .. rubric:: Notes

      It is possible to include an acitvation function to
      give non linear effect of network input; here assumed to be identity





      ..
          !! processed by numpydoc !!


